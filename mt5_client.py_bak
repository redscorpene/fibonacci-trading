import MetaTrader5 as mt5
import pandas as pd
import numpy as np
import requests
import time
import logging
import configparser
from datetime import datetime, timedelta

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("trading_client.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("TradingClient")

class FibonacciTradingClient:
    def __init__(self, config_file='config.ini'):
        """Initialize the Fibonacci trading client"""
        # Load configuration
        self.config = configparser.ConfigParser()
        self.config.read(config_file)
        
        # API settings
        self.api_endpoint = self.config.get('API', 'endpoint')
        self.api_key = self.config.get('API', 'key')
        
        # Trading settings
        self.symbol = self.config.get('Trading', 'symbol', fallback='BTCUSD')
        self.timeframe = self.get_timeframe(self.config.get('Trading', 'timeframe', fallback='5m'))
        self.candles_lookback = self.config.getint('Trading', 'candles_lookback', fallback=50)
        self.check_interval = self.config.getint('Trading', 'check_interval', fallback=5)
        
        # State variables
        self.running = False
        self.active_positions = {}
        self.last_analysis_time = None
    
    def get_timeframe(self, timeframe_str):
        """Convert timeframe string to MT5 timeframe constant"""
        timeframes = {
            '1m': mt5.TIMEFRAME_M1,
            '5m': mt5.TIMEFRAME_M5,
            '15m': mt5.TIMEFRAME_M15,
            '30m': mt5.TIMEFRAME_M30,
            '1h': mt5.TIMEFRAME_H1,
            '4h': mt5.TIMEFRAME_H4,
            '1d': mt5.TIMEFRAME_D1
        }
        return timeframes.get(timeframe_str, mt5.TIMEFRAME_M5)
    
    def initialize(self):
        """Initialize connection to MT5"""
        if not mt5.initialize():
            logger.error("MT5 initialization failed")
            return False
        
        logger.info(f"MT5 connected. Terminal info: {mt5.terminal_info()}")
        logger.info(f"Logged in as: {mt5.account_info().name}, Balance: ${mt5.account_info().balance}")
        
        # Check if symbol is available
        symbol_info = mt5.symbol_info(self.symbol)
        if symbol_info is None:
            logger.error(f"Symbol {self.symbol} not found in MT5")
            return False
        
        logger.info(f"Trading {self.symbol} on {self.get_timeframe_name(self.timeframe)}")
        
        return True
    
    def get_timeframe_name(self, timeframe):
        """Get timeframe name from MT5 timeframe constant"""
        timeframes = {
            mt5.TIMEFRAME_M1: "1-minute",
            mt5.TIMEFRAME_M5: "5-minute",
            mt5.TIMEFRAME_M15: "15-minute",
            mt5.TIMEFRAME_M30: "30-minute",
            mt5.TIMEFRAME_H1: "1-hour",
            mt5.TIMEFRAME_H4: "4-hour",
            mt5.TIMEFRAME_D1: "Daily"
        }
        return timeframes.get(timeframe, "Unknown")
    
    def get_market_data(self):
        """Get current market data from MT5"""
        try:
            # Get current tick data
            tick = mt5.symbol_info_tick(self.symbol)
            if tick is None:
                logger.error("Failed to get current tick data")
                return None
            
            # Current bid and ask prices
            current_bid = tick.bid
            current_ask = tick.ask
            current_time = datetime.fromtimestamp(tick.time)
            
            logger.debug(f"Current prices - Bid: {current_bid}, Ask: {current_ask}")
            
            # Get candles for pattern analysis
            candles = mt5.copy_rates_from_pos(self.symbol, self.timeframe, 0, self.candles_lookback)
            if candles is None or len(candles) == 0:
                logger.error("Failed to get candle data")
                return None
            
            # Convert to the format expected by the API
            candles_data = []
            for candle in candles:
                candles_data.append({
                    "time": datetime.fromtimestamp(candle['time']).isoformat(),
                    "open": candle['open'],
                    "high": candle['high'],
                    "low": candle['low'],
                    "close": candle['close'],
                    "volume": candle['tick_volume']
                })
            
            # Get account info
            account_info = mt5.account_info()
            if account_info is None:
                logger.error("Failed to get account info")
                return None
            
            account_data = {
                "balance": account_info.balance,
                "equity": account_info.equity,
                "margin": account_info.margin,
                "free_margin": account_info.margin_free
            }
            
            # Get active positions
            positions = mt5.positions_get(symbol=self.symbol)
            active_positions = []
            
            if positions is not None and len(positions) > 0:
                for position in positions:
                    # Only include positions created by our system
                    if position.magic == 234000:
                        pos_data = {
                            "ticket": position.ticket,
                            "type": "buy" if position.type == 0 else "sell",
                            "volume": position.volume,
                            "open_price": position.price_open,
                            "sl": position.sl,
                            "tp": position.tp,
                            "profit": position.profit,
                            "fib_redrawn": position.ticket in self.active_positions and self.active_positions[position.ticket].get("fib_redrawn", False)
                        }
                        
                        # Add saved metadata if available
                        if position.ticket in self.active_positions:
                            pos_data.update({
                                "broken_candle_high": self.active_positions[position.ticket].get("broken_candle_high"),
                                "broken_candle_low": self.active_positions[position.ticket].get("broken_candle_low"),
                                "fib_0": self.active_positions[position.ticket].get("fib_0"),
                                "trade_id": self.active_positions[position.ticket].get("trade_id"),
                                "timestamp": self.active_positions[position.ticket].get("timestamp")
                            })
                        
                        active_positions.append(pos_data)
            
            # Current tick data
            current_tick = {
                "bid": current_bid,
                "ask": current_ask,
                "time": current_time.isoformat(),
                "spread": current_ask - current_bid
            }
            
            return {
                "candles": candles_data,
                "account": account_data,
                "active_positions": active_positions,
                "current_tick": current_tick
            }
            
        except Exception as e:
            logger.error(f"Error getting market data: {e}")
            return None
    
    def analyze_market(self):
        """Get market data and send to AI for analysis"""
        # Get latest data from MT5
        market_data = self.get_market_data()
        if market_data is None:
            return None
        
        # Prepare the API request
        request_data = {
            "api_key": self.api_key,
            "candles": market_data["candles"],
            "current_tick": market_data["current_tick"],
            "account": market_data["account"],
            "active_positions": market_data["active_positions"]
        }
        
        # Send to AI service
        try:
            response = requests.post(
                f"{self.api_endpoint}/analyze",
                json=request_data,
                timeout=15
            )
            
            if response.status_code == 200:
                signal = response.json()
                logger.info(f"Received signal: {signal['action']} - {signal['message']}")
                return signal
            else:
                logger.error(f"API error: {response.status_code} - {response.text}")
                return None
        
        except Exception as e:
            logger.error(f"Error sending data to API: {e}")
            return None
    
    def execute_trade_signal(self, signal):
        """Execute the trade signal from AI in MT5"""
        try:
            if signal["action"] == "HOLD":
                logger.info(f"Signal: HOLD - {signal['message']}")
                return
            
            # For BUY signal
            if signal["action"] == "BUY":
                # Prepare trade request
                request = {
                    "action": mt5.TRADE_ACTION_DEAL,
                    "symbol": self.symbol,
                    "volume": signal["lot_size"],
                    "type": mt5.ORDER_TYPE_BUY,
                    "price": mt5.symbol_info_tick(self.symbol).ask,
                    "sl": signal["stop_loss"],
                    "tp": signal["take_profit"],
                    "deviation": 10,
                    "magic": 234000,  # Magic number to identify our trades
                    "comment": f"AI Fib Strategy {'Redraw' if signal['redraw_fibo'] else ''} trade_id:{signal['trade_id']} timestamp:{signal['timestamp']}",
                    "type_time": mt5.ORDER_TIME_GTC,
                    "type_filling": mt5.ORDER_FILLING_IOC
                }
            
            # For SELL signal
            elif signal["action"] == "SELL":
                # Prepare trade request
                request = {
                    "action": mt5.TRADE_ACTION_DEAL,
                    "symbol": self.symbol,
                    "volume": signal["lot_size"],
                    "type": mt5.ORDER_TYPE_SELL,
                    "price": mt5.symbol_info_tick(self.symbol).bid,
                    "sl": signal["stop_loss"],
                    "tp": signal["take_profit"],
                    "deviation": 10,
                    "magic": 234000,  # Magic number to identify our trades
                    "comment": f"AI Fib Strategy {'Redraw' if signal['redraw_fibo'] else ''} trade_id:{signal['trade_id']} timestamp:{signal['timestamp']}",
                    "type_time": mt5.ORDER_TIME_GTC,
                    "type_filling": mt5.ORDER_FILLING_IOC
                }
            
            # Execute trade
            result = mt5.order_send(request)
            
            # Process result
            if result.retcode == mt5.TRADE_RETCODE_DONE:
                logger.info(f"Trade executed successfully: Ticket={result.order}, Volume={signal['lot_size']}, Entry={signal['entry_price']}, SL={signal['stop_loss']}, TP={signal['take_profit']}")
                
                # Store position info for future reference
                self.active_positions[result.order] = {
                    "type": signal["action"].lower(),
                    "volume": signal["lot_size"],
                    "open_price": signal["entry_price"],
                    "sl": signal["stop_loss"],
                    "tp": signal["take_profit"],
                    "fib_redrawn": signal["redraw_fibo"],
                    "trade_id": signal["trade_id"],
                    "timestamp": signal["timestamp"]
                }
                
                return True
            else:
                logger.error(f"Trade execution failed: {result.retcode} - {result.comment}")
                return False
        
        except Exception as e:
            logger.error(f"Error executing trade: {e}")
            return False
    
    def monitor_trades(self):
        """Monitor active trades and report results"""
        while self.running:
            try:
                # Get positions
                positions = mt5.positions_get(symbol=self.symbol)
                current_tickets = set()
                
                if positions:
                    for position in positions:
                        if position.magic == 234000:  # Our system's magic number
                            ticket = position.ticket
                            current_tickets.add(ticket)
                            
                            # Store position in active_positions if not already there
                            if ticket not in self.active_positions:
                                # Retrieve saved metadata from comment if available
                                comment = position.comment
                                metadata = {}
                                
                                if "trade_id:" in comment:
                                    trade_id = comment.split("trade_id:")[1].split()[0]
                                    metadata["trade_id"] = trade_id
                                
                                if "timestamp:" in comment:
                                    timestamp = comment.split("timestamp:")[1].split()[0]
                                    metadata["timestamp"] = timestamp
                                
                                self.active_positions[ticket] = {
                                    "type": "buy" if position.type == 0 else "sell",
                                    "volume": position.volume,
                                    "open_price": position.price_open,
                                    "sl": position.sl,
                                    "tp": position.tp,
                                    "fib_redrawn": False,
                                    "trade_id": metadata.get("trade_id"),
                                    "timestamp": metadata.get("timestamp")
                                }
                
                # Check for closed positions
                closed_tickets = set(self.active_positions.keys()) - current_tickets
                
                for ticket in closed_tickets:
                    position_data = self.active_positions[ticket]
                    
                    # Get trade history to find the closing details
                    from_date = datetime.now() - timedelta(days=1)
                    to_date = datetime.now()
                    
                    # Convert to MT5 format
                    from_date = datetime(from_date.year, from_date.month, from_date.day)
                    to_date = datetime(to_date.year, to_date.month, to_date.day, 23, 59, 59)
                    
                    history_deals = mt5.history_deals_get(
                        from_date, to_date, 
                        position=ticket
                    )
                    
                    if history_deals and len(history_deals) > 0:
                        # Find the closing deal
                        closing_deal = None
                        for deal in history_deals:
                            if deal.entry == 1:  # 1 = out (closing)
                                closing_deal = deal
                                break
                        
                        if closing_deal:
                            # Calculate profit and price distances
                            profit = closing_deal.profit
                            close_price = closing_deal.price
                            
                            # Calculate SL and TP distances as percentage of trade range
                            sl_distance = 0
                            tp_distance = 0
                            
                            if position_data["type"] == "buy":
                                # For buy positions
                                trade_range = position_data["tp"] - position_data["open_price"]
                                if trade_range > 0:
                                    # If closed above SL but below TP
                                    if close_price > position_data["sl"] and close_price < position_data["tp"]:
                                        # How far price moved toward TP
                                        price_move = close_price - position_data["open_price"]
                                        tp_distance = (price_move / trade_range) * 100
                                    elif close_price >= position_data["tp"]:
                                        # Hit TP
                                        tp_distance = 100
                                    elif close_price <= position_data["sl"]:
                                        # Hit SL
                                        sl_distance = -100
                            else:
                                # For sell positions
                                trade_range = position_data["open_price"] - position_data["tp"]
                                if trade_range > 0:
                                    # If closed below SL but above TP
                                    if close_price < position_data["sl"] and close_price > position_data["tp"]:
                                        # How far price moved toward TP
                                        price_move = position_data["open_price"] - close_price
                                        tp_distance = (price_move / trade_range) * 100
                                    elif close_price <= position_data["tp"]:
                                        # Hit TP
                                        tp_distance = 100
                                    elif close_price >= position_data["sl"]:
                                        # Hit SL
                                        sl_distance = -100
                            
                            # Send trade result to API
                            if position_data.get("trade_id") and position_data.get("timestamp"):
                                try:
                                    response = requests.post(
                                        f"{self.api_endpoint}/trade-result",
                                        json={
                                            "trade_id": position_data["trade_id"],
                                            "timestamp": position_data["timestamp"],
                                            "profit": profit,
                                            "sl_distance": sl_distance,
                                            "tp_distance": tp_distance
                                        }
                                    )
                                    
                                    if response.status_code == 200:
                                        logger.info(f"Trade result sent for ticket {ticket}, profit: {profit}")
                                    else:
                                        logger.error(f"Error sending trade result: {response.text}")
                                
                                except Exception as e:
                                    logger.error(f"Error sending trade result: {e}")
                    
                    # Remove from active positions
                    del self.active_positions[ticket]
            
            except Exception as e:
                logger.error(f"Error monitoring trades: {e}")
            
            time.sleep(5)  # Check every 5 seconds
    
    def run(self):
        """Run the trading client"""
        self.running = True
        
        # Start trade monitoring in a separate thread
        import threading
        monitor_thread = threading.Thread(target=self.monitor_trades)
        monitor_thread.daemon = True
        monitor_thread.start()
        
        logger.info("Trading client started")
        
        while self.running:
            try:
                # Get new candle data
                current_time = datetime.now()
                
                # Only analyze at specific intervals
                if self.last_analysis_time is None or (current_time - self.last_analysis_time).total_seconds() >= self.check_interval:
                    # Analyze market
                    signal = self.analyze_market()
                    
                    if signal:
                        # Execute signal
                        if signal["action"] in ["BUY", "SELL"]:
                            self.execute_trade_signal(signal)
                    
                    self.last_analysis_time = current_time
                
                # Sleep before next check
                time.sleep(1)
            
            except KeyboardInterrupt:
                logger.info("Trading client stopping...")
                self.running = False
                break
            
            except Exception as e:
                logger.error(f"Error in main loop: {e}")
                time.sleep(5)  # Sleep longer on error
        
        logger.info("Trading client stopped")
    
    def stop(self):
        """Stop the trading client"""
        self.running = False
        logger.info("Trading client stopping...")

if __name__ == "__main__":
    # Create and run client
    client = FibonacciTradingClient('config.ini')
    
    if client.initialize():
        client.run()
    else:
        logger.error("Failed to initialize client")